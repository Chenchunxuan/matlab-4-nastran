function proteusGeometry2NastranMesh(nastranBulkData,proteusDataStruct,...
    nastranSettingStruct)
%proteusGeometry2NastranMesh Translates the geometry in Proteus to a set of
%Nastran structural nodes and elements.
%   Detailed explanation goes here

% Chord direction
chordDirection = [1,0,0];

% Span direction
spanDirection = [0,1,0];

% Determine number of spars
nSpars = length(proteusDataStruct.constant.Coord3D.Spars_xyzTop);

% Determine ribs y location
ribsIndex = strcmp('Ribs',proteusDataStruct.constant.lumped.type);
ribsYCoordinateVector =...
    proteusDataStruct.constant.lumped.location{ribsIndex}(:,2);

% Create a cell array with the containing in each element the spanwise
% development of each xyz coordinate of the top skin contour
spanwiseTopSkinContourXyzCoordinateArray = arrayfun(@(x) reshape(...
    cell2mat(cellfun(@(y) y(x,:),...
    proteusDataStruct.constant.Coord3D.TopSkin_xyz,'UniformOutput',false)...
    ),3,[])',1:size(proteusDataStruct.constant.Coord3D.TopSkin_xyz{1},1),...
    'UniformOutput',false);
% Create a cell array with the containing in each element the spanwise
% development of each xyz coordinate of the bottom skin contour
spanwiseBottomSkinContourXyzCoordinateArray = flip(arrayfun(@(x) reshape(...
    cell2mat(cellfun(@(y) y(x,:),...
    proteusDataStruct.constant.Coord3D.BotSkin_xyz,'UniformOutput',false)...
    ),3,[])',1:size(proteusDataStruct.constant.Coord3D.BotSkin_xyz{1},1),...
    'UniformOutput',false));
% Retrieve the cell array with the spanwise development of the coordinate
% of the top and bottom point of Proteus' spars
spanwiseSparTopEdgeXyzCoordinateArray =...
    proteusDataStruct.constant.Coord3D.Spars_xyzTop;
spanwiseSparBottomEdgeXyzCoordinateArray =...
    proteusDataStruct.constant.Coord3D.Spars_xyzBot;

%% Determine number of spanwise structural elements
% Determine the y coordinate of the spanwise division points of each region
spanwiseDivisionPointsYCoordinateArray = arrayfun(@(x)...
    [proteusDataStruct.constant.lam.coord{x}(1,2);ribsYCoordinateVector(...
    ribsYCoordinateVector>proteusDataStruct.constant.lam.coord{x}(1,2)&...
    ribsYCoordinateVector<proteusDataStruct.constant.lam.coord{x}(end,2));...
    proteusDataStruct.constant.lam.coord{x}(end,2)],...
    1:length(nastranBulkData.PartArray(1).RegionArray),...
    'UniformOutput',false);
% Determine the number of spanwise patches for each region
spanwisePatchesNoVector =...
    cellfun(@(x) length(x)-1,spanwiseDivisionPointsYCoordinateArray);
% Determine the number of spanwise structural elements for each spanwise
% patch of each region
spanwiseStructuralElementsNoArray = arrayfun(@(x) arrayfun(@(y) ceil(...
    norm(interp1XyzPoints(spanwiseTopSkinContourXyzCoordinateArray{1},...
    spanDirection,spanwiseDivisionPointsYCoordinateArray{x}(y+1))-...
    interp1XyzPoints(spanwiseTopSkinContourXyzCoordinateArray{1},...
    spanDirection,spanwiseDivisionPointsYCoordinateArray{x}(y)))/...
    nastranSettingStruct.structuralEdgeSize),...
    1:spanwisePatchesNoVector(x)),...
    1:length(spanwisePatchesNoVector),'UniformOutput',false);

%% Determine number of chordwise and zwise structural elements
% Determine number of chordwise patches (same for all regions), using the
% number of sub-regions of the first region of the first part
% NB: the way the number of chordwise patches is calculated is probably not
% ideal because it relies on the subregions of the top skin
nChordwisePatches = length(...
    nastranBulkData.PartArray(1).RegionArray(1).SubRegionArray);
% Determine the xyz coordinates of the fore edge of the top skin, for each
% region and for each spanwise division point inside the region
spanwiseDivisionPointsTopSkinForeEdgeXyzCoordinateArray = cellfun(@(x)...
    interp1XyzPoints(spanwiseTopSkinContourXyzCoordinateArray{1},...
    spanDirection,x),spanwiseDivisionPointsYCoordinateArray,...
    'UniformOutput',false);
% Determine the xyz coordinates of the aft edge of the top skin, for each
% region and for each spanwise division point inside the region
spanwiseDivisionPointsTopSkinAftEdgeXyzCoordinateArray = cellfun(@(x)...
    interp1XyzPoints(spanwiseTopSkinContourXyzCoordinateArray{end},...
    spanDirection,x),spanwiseDivisionPointsYCoordinateArray,...
    'UniformOutput',false);
% Determine the xyz coordinates of the top edge of the spars, for each
% region and for each spanwise division point inside the region
spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray = cellfun(@(x)...
    cellfun(@(y) interp1XyzPoints(x,spanDirection,y),...
    spanwiseDivisionPointsYCoordinateArray,'UniformOutput',false),...
    spanwiseSparTopEdgeXyzCoordinateArray,'UniformOutput',false);
% Determine the xyz coordinates of the bottom edge of the spars, for each
% region and for each spanwise division point inside the region
spanwiseDivisionPointsSparBottomEdgeXyzCoordinateArray = cellfun(@(x)...
    cellfun(@(y) interp1XyzPoints(x,spanDirection,y),...
    spanwiseDivisionPointsYCoordinateArray,'UniformOutput',false),...
    spanwiseSparBottomEdgeXyzCoordinateArray,'UniformOutput',false);
% Initialize the array with the x-coordinates of the chordwise division
% points for each region and for each spanwise division point inside the
% region
chordwiseDivisionPointsXCoordinateArray = arrayfun(@(x)...
    spanwiseDivisionPointsTopSkinForeEdgeXyzCoordinateArray{x}(:,1),...
    1:length(spanwiseDivisionPointsTopSkinForeEdgeXyzCoordinateArray),...
    'UniformOutput',false);
% Initialize chordwise patch counter
chordwisePatchNo = 1;
% Iterate through the number of spars
for i = 1:nSpars
    if i~=nSpars
        % If current spar is not the last spar
        if spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{i}{1}(1,1)>...
                chordwiseDivisionPointsXCoordinateArray{1}...
                (1,chordwisePatchNo)
            % If current spar falls after the last recorded division point,
            % then record its x-coordinate as division point
            chordwiseDivisionPointsXCoordinateArray = arrayfun(@(x)...
                [chordwiseDivisionPointsXCoordinateArray{x},...
                spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{i}{...
                x}(:,1)],1:length(chordwiseDivisionPointsXCoordinateArray),...
                'UniformOutput',false);
            % Increase patch counter
            chordwisePatchNo = chordwisePatchNo+1;
        end
        if nastranSettingStruct.flangeSize>0
            % If flange is included, then record the x-coordinate of
            % the flange end as division point
            chordwiseDivisionPointsXCoordinateArray = arrayfun(@(x)...
                [chordwiseDivisionPointsXCoordinateArray{x},...
                chordwiseDivisionPointsXCoordinateArray{x}(:,end)+...
                nastranSettingStruct.flangeSize],...
                1:length(chordwiseDivisionPointsXCoordinateArray),...
                'UniformOutput',false);
            % Increase patch counter
            chordwisePatchNo = chordwisePatchNo+1;
        end
    else
        % If current spar is the last spar
        if nastranSettingStruct.flangeSize>0
            % If flange is included, then record the x-coordinate of
            % the flange end as division point
            chordwiseDivisionPointsXCoordinateArray = arrayfun(@(x)...
                [chordwiseDivisionPointsXCoordinateArray{x},...
                spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{i}{x}(:,...
                1)-nastranSettingStruct.flangeSize],...
                1:length(chordwiseDivisionPointsXCoordinateArray),...
                'UniformOutput',false);
            % Increase patch counter
            chordwisePatchNo = chordwisePatchNo+1;
        end
        if spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{i}{1}(1,1)<...
                spanwiseDivisionPointsTopSkinAftEdgeXyzCoordinateArray{1}...
                (1,1)
            % If current spar falls before the last division point,
            % then record its x-coordinate as division point
            chordwiseDivisionPointsXCoordinateArray = arrayfun(@(x)...
                [chordwiseDivisionPointsXCoordinateArray{x},...
                spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{i}{x}(:,...
                1)],1:length(chordwiseDivisionPointsXCoordinateArray),...
                'UniformOutput',false);
            % Increase patch counter
            chordwisePatchNo = chordwisePatchNo+1;
        end
    end
end
% Add x-coordinate of last chordwise division point using the aft edge of
% the top skin
chordwiseDivisionPointsXCoordinateArray = arrayfun(@(x)...
    [chordwiseDivisionPointsXCoordinateArray{x},...
    spanwiseDivisionPointsTopSkinAftEdgeXyzCoordinateArray{x}(:,1)],...
    1:length(spanwiseDivisionPointsTopSkinAftEdgeXyzCoordinateArray),...
    'UniformOutput',false);
% Generate the vector with the x-coordinate of the chordwise division
% points at the root
rootChordwiseDivisionPointsXCoordinateVector =...
    chordwiseDivisionPointsXCoordinateArray{1}(1,:);
% Determine the number of chordwise structural elements for each chordwise
% patch
chordwiseStructuralElementsNoVector = arrayfun(@(x) ceil(norm(...
    interp1XyzPoints(proteusDataStruct.constant.Coord3D.TopSkin_xyz{1},...
    chordDirection,rootChordwiseDivisionPointsXCoordinateVector(x+1)-...
    rootChordwiseDivisionPointsXCoordinateVector(1))-...
    interp1XyzPoints(proteusDataStruct.constant.Coord3D.TopSkin_xyz{1},...
    chordDirection,rootChordwiseDivisionPointsXCoordinateVector(x)-...
    rootChordwiseDivisionPointsXCoordinateVector(1)))/...
    nastranSettingStruct.structuralEdgeSize),...
    1:nChordwisePatches);
% Determine the number of zwise structural elements using the heighest spar
nZwiseStructuralElements = max(cell2mat(arrayfun(@(x)...
    ceil(norm(spanwiseSparTopEdgeXyzCoordinateArray{x}(1,:)-...
    spanwiseSparBottomEdgeXyzCoordinateArray{x}(1,:))/...
    nastranSettingStruct.structuralEdgeSize),...
    1:length(spanwiseSparTopEdgeXyzCoordinateArray),...
    'UniformOutput',false)));

%% Generate mesh
% Iterate through regions
for i = 1:length(spanwisePatchesNoVector)
    % Retrieve current regions
    topSkinCurrentRegion = nastranBulkData.PartArray(1).RegionArray(i);
    bottomSkinCurrentRegion = nastranBulkData.PartArray(2).RegionArray(i);
    ribCurrentRegion = nastranBulkData.PartArray(end).RegionArray;
    % Iterate through spanwise patches of current region
    for j = 1:spanwisePatchesNoVector(i)
        % Iterate through chordiwse patches
        for k = 1:nChordwisePatches
            % Top skin
            % Define patch south boundary
            topSkinPatchBoundaryStruct.southBoundary = cell2mat(...
                cellfun(@(x) interp1XyzPoints(x,spanDirection,...
                spanwiseDivisionPointsYCoordinateArray{i}(j)),...
                spanwiseTopSkinContourXyzCoordinateArray,...
                'UniformOutput',false)');
            % The order of the points of the south boundary is flipped so
            % that the y-axis of the top skin goes leading edge to trailing
            % edge
            topSkinPatchBoundaryStruct.southBoundary = flipud([interp1XyzPoints(...
                topSkinPatchBoundaryStruct.southBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j,1));...
                topSkinPatchBoundaryStruct.southBoundary(...
                topSkinPatchBoundaryStruct.southBoundary(:,1)>...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k)&...
                topSkinPatchBoundaryStruct.southBoundary(:,1)<...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k+1),:);...
                interp1XyzPoints(...
                topSkinPatchBoundaryStruct.southBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k+1)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j,1))]);
            % Define patch north boundary
            topSkinPatchBoundaryStruct.northBoundary = cell2mat(...
                cellfun(@(x) interp1XyzPoints(x,spanDirection,...
                spanwiseDivisionPointsYCoordinateArray{i}(j+1)),...
                spanwiseTopSkinContourXyzCoordinateArray,...
                'UniformOutput',false)');            
            % The order of the points of the north boundary is flipped so
            % that the y-axis of the top skin goes leading edge to trailing
            % edge
            topSkinPatchBoundaryStruct.northBoundary = flipud([interp1XyzPoints(...
                topSkinPatchBoundaryStruct.northBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,1));...
                topSkinPatchBoundaryStruct.northBoundary(...
                topSkinPatchBoundaryStruct.northBoundary(:,1)>...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k)&...
                topSkinPatchBoundaryStruct.northBoundary(:,1)<...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k+1),:);...
                interp1XyzPoints(...
                topSkinPatchBoundaryStruct.northBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k+1)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,1))]);
            % Generate patch nodes and elements
            [patchGridVector,patchElementArray] = patch2NastranMesh(...
                topSkinPatchBoundaryStruct,...
                spanwiseStructuralElementsNoArray{i}(j),...
                chordwiseStructuralElementsNoVector(k),...
                nastranSettingStruct,...
                topSkinCurrentRegion.ElementProperty.Pid);
            % Assign element array from current patch to current region
            topSkinCurrentRegion.SubRegionArray(k).ElementArray =...
                [topSkinCurrentRegion.SubRegionArray(k).ElementArray;...
                patchElementArray];
            nastranBulkData.GridArray = [nastranBulkData.GridArray;...
                patchGridVector];
            % Bottom skin
            % Define patch south boundary
            bottomSkinPatchBoundaryStruct.southBoundary = cell2mat(...
                cellfun(@(x) interp1XyzPoints(x,spanDirection,...
                spanwiseDivisionPointsYCoordinateArray{i}(j)),...
                spanwiseBottomSkinContourXyzCoordinateArray,...
                'UniformOutput',false)');
            bottomSkinPatchBoundaryStruct.southBoundary =...
                [interp1XyzPoints(...
                bottomSkinPatchBoundaryStruct.southBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j,1));...
                bottomSkinPatchBoundaryStruct.southBoundary(...
                bottomSkinPatchBoundaryStruct.southBoundary(:,1)>...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k)&...
                bottomSkinPatchBoundaryStruct.southBoundary(:,1)<...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k+1),:);...
                interp1XyzPoints(...
                bottomSkinPatchBoundaryStruct.southBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j,k+1)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j,1))];
            % Define patch north boundary
            bottomSkinPatchBoundaryStruct.northBoundary = cell2mat(...
                cellfun(@(x) interp1XyzPoints(x,spanDirection,...
                spanwiseDivisionPointsYCoordinateArray{i}(j+1)),...
                spanwiseBottomSkinContourXyzCoordinateArray,...
                'UniformOutput',false)');
            bottomSkinPatchBoundaryStruct.northBoundary =...
                [interp1XyzPoints(...
                bottomSkinPatchBoundaryStruct.northBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,1));...
                bottomSkinPatchBoundaryStruct.northBoundary(...
                bottomSkinPatchBoundaryStruct.northBoundary(:,1)>...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k)&...
                bottomSkinPatchBoundaryStruct.northBoundary(:,1)<...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k+1),:);...
                interp1XyzPoints(...
                bottomSkinPatchBoundaryStruct.northBoundary,chordDirection,...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,k+1)-...
                chordwiseDivisionPointsXCoordinateArray{i}(j+1,1))];
            % Generate patch nodes and elements
            [patchGridVector,patchElementArray] = patch2NastranMesh(...
                bottomSkinPatchBoundaryStruct,...
                spanwiseStructuralElementsNoArray{i}(j),...
                chordwiseStructuralElementsNoVector(k),...
                nastranSettingStruct,...
                bottomSkinCurrentRegion.ElementProperty.Pid);
            % Assign element array from current patch to current region
            bottomSkinCurrentRegion.SubRegionArray(k).ElementArray =...
                [bottomSkinCurrentRegion.SubRegionArray(k).ElementArray;...
                patchElementArray];
            nastranBulkData.GridArray = [nastranBulkData.GridArray;...
                patchGridVector];
            % Rib
            if i==1 && j == 1
                % If current spanwise patch is the first one of the first
                % region, take care of the first rib
                if any(spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                        ribsYCoordinateVector)
                    % If current spanwise division point coincides with a
                    % rib, construct south and north boundary as south 
                    % boundary of bottom and top skin respectively
                    ribPatchBoundaryStruct.southBoundary =...
                        bottomSkinPatchBoundaryStruct.southBoundary;
                    ribPatchBoundaryStruct.northBoundary =...
                        flipud(topSkinPatchBoundaryStruct.southBoundary);
                    % Generate patch nodes and elements
                    [patchGridVector,patchElementArray] =...
                        patch2NastranMesh(ribPatchBoundaryStruct,...
                        nZwiseStructuralElements,...
                        chordwiseStructuralElementsNoVector(k),...
                        nastranSettingStruct,...
                        ribCurrentRegion.ElementProperty.Pid);
                    if iscell(ribCurrentRegion.SubRegionArray(...
                            spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                            ribsYCoordinateVector).ElementArray) &&...
                            ~iscell(patchElementArray)
                        % If element array of current sub-region is a cell
                        % array and the element array of the current patch
                        % is not, then make the element array of the
                        % current patch a cell array
                        patchElementArray = num2cell(patchElementArray);
                    elseif ~iscell(ribCurrentRegion.SubRegionArray(...
                            spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                            ribsYCoordinateVector).ElementArray) &&...
                            iscell(patchElementArray)
                        % If element array of current patch is a cell array
                        % and the element array of the current sub-region
                        % is not, then make the element array of the
                        % current sub-region a cell array
                        ribCurrentRegion.SubRegionArray(...
                            spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                            ribsYCoordinateVector).ElementArray =...
                            num2cell(ribCurrentRegion.SubRegionArray(...
                            spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                            ribsYCoordinateVector).ElementArray);
                    end
                    % Assign element array from current patch to current
                    % region
                    ribCurrentRegion.SubRegionArray(...
                        spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                        ribsYCoordinateVector).ElementArray =...
                        [ribCurrentRegion.SubRegionArray(...
                        spanwiseDivisionPointsYCoordinateArray{i}(j) ==...
                        ribsYCoordinateVector).ElementArray,...
                        patchElementArray];
                    % Add grid vector from current patch to general grid
                    % vector
                    nastranBulkData.GridArray =...
                        [nastranBulkData.GridArray;patchGridVector];
                end
            end
            % Take care of all other ribs
            if any(spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                    ribsYCoordinateVector)
                % If current spanwise division point coincides with a rib,
                % construct south and north boundary as north boundary of
                % bottom and top skin respectively
                ribPatchBoundaryStruct.southBoundary =...
                    bottomSkinPatchBoundaryStruct.northBoundary;
                ribPatchBoundaryStruct.northBoundary =...
                    flipud(topSkinPatchBoundaryStruct.northBoundary);
                % Generate patch nodes and elements
                [patchGridVector,patchElementArray] = patch2NastranMesh(...
                    ribPatchBoundaryStruct,...
                    nZwiseStructuralElements,...
                    chordwiseStructuralElementsNoVector(k),...
                    nastranSettingStruct,...
                    ribCurrentRegion.ElementProperty.Pid);
                if iscell(ribCurrentRegion.SubRegionArray(...
                        spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                        ribsYCoordinateVector).ElementArray) &&...
                        ~iscell(patchElementArray)
                    % If element array of current sub-region is a cell
                    % array and the element array of the current patch
                    % is not, then make the element array of the
                    % current patch a cell array
                    patchElementArray = num2cell(patchElementArray);
                elseif ~iscell(ribCurrentRegion.SubRegionArray(...
                        spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                        ribsYCoordinateVector).ElementArray) &&...
                        iscell(patchElementArray)
                    % If element array of current patch is a cell array
                    % and the element array of the current sub-region
                    % is not, then make the element array of the
                    % current sub-region a cell array
                    ribCurrentRegion.SubRegionArray(...
                        spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                        ribsYCoordinateVector).ElementArray =...
                        num2cell(ribCurrentRegion.SubRegionArray(...
                        spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                        ribsYCoordinateVector).ElementArray);
                end
                % Assign element array from current patch to current region
                ribCurrentRegion.SubRegionArray(...
                    spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                    ribsYCoordinateVector).ElementArray =...
                    [ribCurrentRegion.SubRegionArray(...
                    spanwiseDivisionPointsYCoordinateArray{i}(j+1) ==...
                    ribsYCoordinateVector).ElementArray,...
                    patchElementArray];
                % Add grid vector from current patch to general grid vector
                nastranBulkData.GridArray = [nastranBulkData.GridArray;...
                    patchGridVector];
            end
        end
        % Spars
        if nSpars>0
            % If at least one spar is included in the geometry, then
            % iterate through the spars
            for k = 3:2+nSpars
                % Retrieve current region of current spar
                sparCurrentRegion =...
                    nastranBulkData.PartArray(k).RegionArray(i);
                % Define boundaries of spar web
                sparPatchBoundaryStruct.southBoundary =...
                    [spanwiseDivisionPointsSparBottomEdgeXyzCoordinateArray{k-2}{i}(j,:);...
                    spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{k-2}{i}(j,:)];
                sparPatchBoundaryStruct.northBoundary =...
                    [spanwiseDivisionPointsSparBottomEdgeXyzCoordinateArray{k-2}{i}(j+1,:);...
                    spanwiseDivisionPointsSparTopEdgeXyzCoordinateArray{k-2}{i}(j+1,:)];
                % Generate patch nodes and elements
                [patchGridVector,patchElementArray] = patch2NastranMesh(...
                    sparPatchBoundaryStruct,...
                    spanwiseStructuralElementsNoArray{i}(j),...
                    nZwiseStructuralElements,...
                    nastranSettingStruct,...
                    sparCurrentRegion.ElementProperty.Pid);
                % Distinguish between spar with web only and spar with
                % flange and web
                if isempty(nastranBulkData.PartArray(k).RegionArray(...
                        i).SubRegionArray)
                    % If current region of current spar has only one
                    % sub-region (web only), assign element array from
                    % current patch to the sub-region
                    sparCurrentRegion.ElementArray =...
                        [sparCurrentRegion.ElementArray;...
                        patchElementArray];
                    nastranBulkData.GridArray = [nastranBulkData.GridArray;...
                        patchGridVector];
                else
                    % If current region of current spar has more than one
                    % sub-region (flanges included), assign element array
                    % from current patch to the second sub-region
                    sparCurrentRegion.SubRegionArray(2).ElementArray =...
                        [sparCurrentRegion.SubRegionArray(2).ElementArray;...
                        patchElementArray];
                    nastranBulkData.GridArray = [nastranBulkData.GridArray;...
                        patchGridVector];
                    if j == spanwisePatchesNoVector(i)
                        % If current spanwise patch is the last one of the
                        % current region, then generate the element array
                        % of sub-regions 1 and 3 (flanges) using the
                        % corresponding overlay regions
                        sparCurrentRegion.SubRegionArray(...
                            1).generateElementsFromOverlayRegion(...
                            nastranSettingStruct.lastElementId,-1);
                        sparCurrentRegion.SubRegionArray(...
                            3).generateElementsFromOverlayRegion(...
                            nastranSettingStruct.lastElementId,-1);
                    end
                end
            end
        end
    end
end

%% Assign ParentPart to all elements
nastranBulkData.PartArray.assignParentPart2Elements;

%% Eliminate duplicate nodes
% Initialize iteration index
i = 1;
% Iterate until the iteration index is lower than the number of duplicated
% nodes
fprintf('\nRemoving duplicate nodes\n')
while i < length(nastranBulkData.GridArray)
    fprintf('%d/%d\n',i,length(nastranBulkData.GridArray))
    % Save the reference node
    referenceGrid = nastranBulkData.GridArray(i);
    % Save the remaining nodes
    remainingGridVector = nastranBulkData.GridArray(i+1:end);
    % Find the indexes of the duplicates of the reference nodes
    duplicateGridIndexVector = vecnorm(repmat(referenceGrid.getXyzArray,...
        length(remainingGridVector),1)-...
        remainingGridVector.getXyzArray,2,2)<...
        nastranSettingStruct.structuralEdgeSize*1e-3;
    % Apply indexes to retrieve Grid object vector
    duplicateGridVector = remainingGridVector(duplicateGridIndexVector);
    % Iterate through the duplicates of the reference node
    for j = 1:length(duplicateGridVector)
        % Iterate through the parent elements of the current duplicate node
        for k = 1:length(duplicateGridVector(j).ParentElement)
            % Find the index of the current duplicate node within the nodes
            % of the current parent element and substitute the duplicated
            % node with the reference node
            if iscell(duplicateGridVector(j).ParentElement(k))
                gridIndex = ...
                    [duplicateGridVector(j).ParentElement{k...
                    }.GridArray.Id] == duplicateGridVector(j).Id;
                duplicateGridVector(j).ParentElement{k...
                    }.GridArray(gridIndex) = referenceGrid;
            else
                gridIndex = ...
                    [duplicateGridVector(j).ParentElement(k...
                    ).GridArray.Id] == duplicateGridVector(j).Id;
                duplicateGridVector(j).ParentElement(k...
                    ).GridArray(gridIndex) = referenceGrid;
            end
        end
    end
    % Delete duplicated nodes from the main Grid object vector
    nastranBulkData.GridArray([false(i,1);duplicateGridIndexVector]) = [];
    % Update counter
    i = i + 1;
end
end
