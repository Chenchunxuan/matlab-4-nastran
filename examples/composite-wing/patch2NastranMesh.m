function [gridVector,elementArray] = patch2NastranMesh(...
    patchBoundaryStruct,nXElements,nYElements,nastranSettingStruct,...
    propertyId)
%patch2NastranMesh Generates a set of Grid, Cquad4 and Ctria3 objects.
%   [gridVector,elementArray] = patch2NastranMesh(...
%   patchBoundaryStruct,nXElements,nYElements,nastranSettingStruct,...
%   propertyId) generates a shell element mesh for Nastran out of a
%   geometrical patch. It takes as input a structure with the south and
%   north boundary of the geometrical patch, the number of desired elements
%   in the x and y direction, another structure containing the settings for
%   the generation of the Nastran model and the ID of the element property
%   card related to the desired elements. The patch reference system is as
%   follows: the x direction is south to north and the y direction is west
%   to east. The quadrilateral elements are created in such a way that
%   their x axes goes south to north, while the y axes goes east to west.

%% Find raw coordiates of patch grid points
% Find points along the patch south and north boundary, according to the
% number of elements along the y direction
patchBoundaryStruct = structfun(@(x) interp1XyzPoints(x,...
    (x(end,:)-x(1,:))/norm(x(end,:)-x(1,:)),...
    0:norm(x(end,:)-x(1,:))/nYElements:norm(x(end,:)-x(1,:))),...
    patchBoundaryStruct,'UniformOutput',false);

if norm(patchBoundaryStruct.northBoundary(1,:)-...
        patchBoundaryStruct.southBoundary(1,:))<...
        nastranSettingStruct.structuralEdgeSize*1e-3
    % If north and south boundaries converge in one unique west point, set
    % flags and generate the cell array with the coordinates of the grid
    % points of the patch, including a single point for the west boundary
    flagWest = true;
    flagEast = false;
    patchGridXyzCoordinateArray = [...
        {(patchBoundaryStruct.northBoundary(1,:)+...
        patchBoundaryStruct.southBoundary(1,:))/2},...
        arrayfun(@(x) interp1XyzPoints(...
        [patchBoundaryStruct.southBoundary(x,:);...
        patchBoundaryStruct.northBoundary(x,:)],...
        (patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))/...
        norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:)),...
        0:norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))/nXElements:...
        norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))),...
        2:size(patchBoundaryStruct.southBoundary,1),...
        'UniformOutput',false)];
elseif norm(patchBoundaryStruct.northBoundary(end,:)-...
        patchBoundaryStruct.southBoundary(end,:))<...
        nastranSettingStruct.structuralEdgeSize*1e-3
    % If north and south boundaries converge in one unique east point, set
    % flags and generate the cell array with the coordinates of the grid
    % points of the patch, including a single point for the east boundary
    flagWest = false;
    flagEast = true;
    patchGridXyzCoordinateArray = [arrayfun(@(x) interp1XyzPoints(...
        [patchBoundaryStruct.southBoundary(x,:);...
        patchBoundaryStruct.northBoundary(x,:)],...
        (patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))/...
        norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:)),...
        0:norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))/nXElements:...
        norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))),...
        1:size(patchBoundaryStruct.southBoundary,1)-1,...
        'UniformOutput',false),...
        {(patchBoundaryStruct.northBoundary(end,:)+...
        patchBoundaryStruct.southBoundary(end,:))/2}];
else
    % If north and south boundaries do not converge in one unique point at
    % all, then set flags and generate the cell array with the coordinates
    % of grid points of the patch
    flagWest = false;
    flagEast = false;
    patchGridXyzCoordinateArray = arrayfun(@(x) interp1XyzPoints(...
        [patchBoundaryStruct.southBoundary(x,:);...
        patchBoundaryStruct.northBoundary(x,:)],...
        (patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))/...
        norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:)),...
        0:norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))/nXElements:...
        norm(patchBoundaryStruct.northBoundary(x,:)-...
        patchBoundaryStruct.southBoundary(x,:))),...
        1:size(patchBoundaryStruct.southBoundary,1),'UniformOutput',false);
end

%% Generate Grid objects
% Iterate through the cell array containing the raw coordinates of the grid
% points (y direction)
for j = length(patchGridXyzCoordinateArray):-1:1
    % Iterate through the coordinates of current cell (x direction)
    for i = size(patchGridXyzCoordinateArray{j},1):-1:1
        % Assemble structure for Grid object generation
        gridStruct(i,j).xyzVector = patchGridXyzCoordinateArray{j}(i,:);
        gridStruct(i,j).id = nastranSettingStruct.lastGridId.addId;
    end
end
% Generate Grid object
gridArray = Grid(gridStruct);
% Retrieve vector with all Grid objects
gridVector = gridArray(:);
% Eliminate from grid vector the objects without an actual grid point
gridVector = gridVector(arrayfun(@(x) ~isempty(x.Id),gridVector));

%% Generate elements
if flagWest
    % If flagWest is active, then the elements in the first row along the
    % y-direction must be triangular
    for i = nXElements:-1:1
        j = 1;
        ctria3Strcut = struct(...
            'eid',nastranSettingStruct.lastElementId.addId,...
            'pid',propertyId,...
            'gridArray',...
            [gridArray(i,j+1),gridArray(i+1,j+1),gridArray(1,1)]);
        elementArray{i,j} = Ctria3(ctria3Strcut);
        for j = nYElements:-1:2
            cquad4Struct = struct(...
                'eid',nastranSettingStruct.lastElementId.addId,...
                'pid',propertyId,...
                'gridArray',[gridArray(i,j+1),gridArray(i+1,j+1),...
                gridArray(i+1,j),gridArray(i,j)]);
            elementArray{i,j} = Cquad4(cquad4Struct);
        end
    end
elseif flagEast
    % If flagEast is active, then the elements in the last row along the
    % y-direction must be triangular
    for i = nXElements:-1:1
        j = nYElements;
        % The arrengment of the grid points in the structure makes the
        % x-axis of the triangular elements parallel to the x-axis of all
        % other elements in the patch, however the y-axis will be opposite
        % with respect to the y-axis of all other elements
        ctria3Strcut = struct(...
            'eid',nastranSettingStruct.lastElementId.addId,...
            'pid',propertyId,...
            'gridArray',...
            [gridArray(i,j),gridArray(i+1,j),gridArray(1,end)]);
        elementArray{i,j} = Ctria3(ctria3Strcut);
        for j = nYElements-1:-1:1
            cquad4Struct = struct(...
                'eid',nastranSettingStruct.lastElementId.addId,...
                'pid',propertyId,...
                'gridArray',[gridArray(i,j+1),gridArray(i+1,j+1),...
                gridArray(i+1,j),gridArray(i,j)]);
            elementArray{i,j} = Cquad4(cquad4Struct);
        end
    end
else
    % If no flag is active, then there is no triangular element
    for i = nXElements:-1:1
        for j = nYElements:-1:1
            cquad4Struct(i,j).eid = nastranSettingStruct.lastElementId.addId;
            cquad4Struct(i,j).pid = propertyId;
            cquad4Struct(i,j).gridArray =...
                [gridArray(i,j+1),gridArray(i+1,j+1),...
                gridArray(i+1,j),gridArray(i,j)];
        end
    end
    elementArray = Cquad4(cquad4Struct);
end
end
